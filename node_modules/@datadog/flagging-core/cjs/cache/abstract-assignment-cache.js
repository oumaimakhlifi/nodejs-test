"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractAssignmentCache = void 0;
exports.assignmentCacheKeyToString = assignmentCacheKeyToString;
exports.assignmentCacheValueToString = assignmentCacheValueToString;
const obfuscation_1 = require("../obfuscation");
/** Converts an {@link AssignmentCacheKey} to a string. */
function assignmentCacheKeyToString(exposureEvent) {
    const key = {
        flag: {
            key: exposureEvent.flag.key,
        },
        subject: {
            id: exposureEvent.subject.id,
            attributes: exposureEvent.subject.attributes,
        },
    };
    return (0, obfuscation_1.getMD5Hash)(JSON.stringify(key));
}
/** Converts an {@link AssignmentCacheValue} to a string. */
function assignmentCacheValueToString(cacheValue) {
    return (0, obfuscation_1.getMD5Hash)(JSON.stringify(cacheValue));
}
class AbstractAssignmentCache {
    // key -> variation value hash
    constructor(delegate) {
        this.delegate = delegate;
    }
    init() {
        return Promise.resolve();
    }
    /** Returns whether the provided {@link AssignmentCacheEntry} is present in the cache. */
    has(entry) {
        return this.get(entry) === assignmentCacheValueToString(entry);
    }
    get(key) {
        return this.delegate.get(assignmentCacheKeyToString(key));
    }
    /**
     * Stores the provided {@link AssignmentCacheEntry} in the cache. If the key already exists, it
     * will be overwritten.
     */
    set(entry) {
        this.delegate.set(assignmentCacheKeyToString(entry), assignmentCacheValueToString(entry));
    }
    /**
     * Returns an array with all {@link AssignmentCacheEntry} entries in the cache as an array of
     * {@link string}s.
     */
    entries() {
        return this.delegate.entries();
    }
    /** Clears all entries from the cache. */
    clear() {
        this.delegate.clear();
    }
}
exports.AbstractAssignmentCache = AbstractAssignmentCache;
//# sourceMappingURL=abstract-assignment-cache.js.map