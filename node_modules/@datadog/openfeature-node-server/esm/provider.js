import { createExposureEvent, LRUInMemoryAssignmentCache, } from '@datadog/flagging-core';
import { OpenFeatureEventEmitter, ProviderEvents } from '@openfeature/server-sdk';
import { evaluate } from './configuration/evaluation';
export class DatadogNodeServerProvider {
    constructor(options) {
        this.options = options;
        this.metadata = {
            name: 'datadog-node-server',
        };
        this.runsOn = 'server';
        this.hooks = [];
        this.events = new OpenFeatureEventEmitter();
        this.exposureCache = new LRUInMemoryAssignmentCache(50000);
    }
    /**
     * Used by dd-source-js
     */
    getConfiguration() {
        return this.configuration;
    }
    /**
     * Used by dd-source-js
     */
    setConfiguration(configuration) {
        var _a, _b;
        const prevCreatedAt = (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.createdAt;
        if (this.configuration && this.configuration !== configuration) {
            this.events.emit(ProviderEvents.ConfigurationChanged);
            const newCreatedAt = configuration === null || configuration === void 0 ? void 0 : configuration.createdAt;
            if (prevCreatedAt !== newCreatedAt) {
                (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.clear();
            }
            this.configuration = configuration;
            return;
        }
        this.configuration = configuration;
        if (this.resolveInitialization) {
            this.resolveInitialization();
            this.resolveInitialization = undefined;
            this.rejectInitialization = undefined;
        }
    }
    /**
     * Used by dd-source-js
     */
    setError(error) {
        if (this.rejectInitialization) {
            this.rejectInitialization(error);
            this.resolveInitialization = undefined;
            this.rejectInitialization = undefined;
        }
        else {
            this.events.emit(ProviderEvents.Error, { error });
        }
    }
    /**
     * Used by the OpenFeature SDK to set the status based on initialization.
     * Status of 'PROVIDER_READY' is emitted with a resolved promise.
     * Status of 'PROVIDER_ERROR' is emitted with a rejected promise.
     *
     * Since we aren't loading the configuration in this Provider, we will simulate
     * loading functionality via resolveInitialization and rejectInitialization.
     * See setConfiguration and setError for more details.
     */
    async initialize() {
        var _a;
        if (this.configuration) {
            return;
        }
        await new Promise((resolve, reject) => {
            this.resolveInitialization = resolve;
            this.rejectInitialization = reject;
        });
        await ((_a = this.exposureCache) === null || _a === void 0 ? void 0 : _a.init());
    }
    async resolveBooleanEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'boolean', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveStringEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'string', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveNumberEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'number', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveObjectEvaluation(flagKey, defaultValue, context, _logger) {
        // type safety: OpenFeature interface requires us to return a
        // specific T for *any* value of T (which could be any subtype of
        // JsonValue). We can't even theoretically implement it in a
        // type-sound way because there's no runtime information passed to
        // learn what type the user expects. So it's up to the user to
        // make sure they pass the appropriate type.
        const resolutionDetails = evaluate(this.configuration, 'object', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    handleExposure(flagKey, context, resolutionDetails) {
        var _a, _b, _c;
        const timestamp = Date.now();
        const evalutationDetails = {
            ...resolutionDetails,
            flagKey: flagKey,
            flagMetadata: (_a = resolutionDetails.flagMetadata) !== null && _a !== void 0 ? _a : {},
        };
        const exposureEvent = createExposureEvent(context, evalutationDetails);
        if (!exposureEvent) {
            return;
        }
        const hasLoggedAssignment = (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.has(exposureEvent);
        if (hasLoggedAssignment) {
            return;
        }
        if (this.options.exposureChannel.hasSubscribers) {
            this.options.exposureChannel.publish({ ...exposureEvent, timestamp });
            (_c = this.exposureCache) === null || _c === void 0 ? void 0 : _c.set(exposureEvent);
        }
    }
}
//# sourceMappingURL=provider.js.map