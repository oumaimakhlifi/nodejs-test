"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateForSubject = evaluateForSubject;
exports.containsMatchingRule = containsMatchingRule;
const server_sdk_1 = require("@openfeature/server-sdk");
const rules_1 = require("../rules/rules");
const matchesShard_1 = require("../shards/matchesShard");
const ufc_v1_1 = require("./ufc-v1");
function evaluateForSubject(flag, type, subjectKey, subjectAttributes, defaultValue, logger) {
    if (!(flag === null || flag === void 0 ? void 0 : flag.enabled)) {
        logger.debug(`returning default assignment because flag is disabled`, {
            flagKey: flag ? flag.key : 'undefined',
            subjectKey,
        });
        return {
            value: defaultValue,
            reason: server_sdk_1.StandardResolutionReasons.DISABLED,
        };
    }
    const isValid = validateTypeMatch(type, flag.variationType);
    if (!isValid) {
        logger.debug(`variant value type mismatch, returning default value`, {
            flagKey: flag.key,
            subjectKey,
            expectedType: type,
            variantType: flag.variationType,
        });
        return {
            value: defaultValue,
            reason: server_sdk_1.StandardResolutionReasons.ERROR,
            errorCode: server_sdk_1.ErrorCode.TYPE_MISMATCH,
        };
    }
    const now = new Date();
    for (const allocation of flag.allocations) {
        if (allocation.startAt && now < new Date(allocation.startAt)) {
            logger.debug(`allocation before start date`, {
                flagKey: flag.key,
                subjectKey,
                allocationKey: allocation.key,
                startAt: allocation.startAt,
            });
            continue;
        }
        if (allocation.endAt && now >= new Date(allocation.endAt)) {
            logger.debug(`allocation after end date`, {
                flagKey: flag.key,
                subjectKey,
                allocationKey: allocation.key,
                endAt: allocation.endAt,
            });
            continue;
        }
        const matched = containsMatchingRule(allocation.rules, subjectAttributes, logger);
        if (!matched) {
            continue;
        }
        const selectedSplit = selectSplitUsingSharding(allocation.splits, subjectKey, flag.key, logger);
        if (selectedSplit) {
            const variant = flag.variations[selectedSplit.variationKey];
            if (variant) {
                logger.debug(`evaluated a flag`, {
                    flagKey: flag.key,
                    subjectKey,
                    assignment: variant.value,
                });
                return {
                    value: variant.value,
                    reason: server_sdk_1.StandardResolutionReasons.TARGETING_MATCH,
                    variant: variant.key,
                    flagMetadata: {
                        allocationKey: allocation.key,
                        variationType: (0, ufc_v1_1.variantTypeToFlagValueType)(flag.variationType),
                        doLog: !!allocation.doLog,
                    },
                };
            }
        }
        else {
            logger.debug(`no matching split found for subject`, {
                flagKey: flag.key,
                subjectKey,
                allocationKey: allocation.key,
            });
        }
    }
    // This shouldn't happen since a default allocation is generated by the server
    logger.debug(`returning default assignment because no allocation matched`, {
        flagKey: flag.key,
        subjectKey,
    });
    return {
        value: defaultValue,
        reason: server_sdk_1.StandardResolutionReasons.DEFAULT,
    };
}
function validateTypeMatch(expectedType, variantType) {
    if (expectedType === 'boolean') {
        return variantType === 'BOOLEAN';
    }
    if (expectedType === 'string') {
        return variantType === 'STRING';
    }
    if (expectedType === 'number') {
        return variantType === 'INTEGER' || variantType === 'NUMERIC';
    }
    if (expectedType === 'object') {
        return variantType === 'JSON';
    }
    throw new Error(`Invalid expected type: ${expectedType}`);
}
function containsMatchingRule(rules, subjectAttributes, logger) {
    if (!(rules === null || rules === void 0 ? void 0 : rules.length)) {
        return true;
    }
    logger.debug(`evaluating rules`, {
        rules: JSON.stringify(rules),
        subjectAttributes,
    });
    return rules.some((rule) => (0, rules_1.matchesRule)(rule, subjectAttributes));
}
function selectSplitUsingSharding(splits, subjectKey, flagKey, logger) {
    if (!splits || splits.length === 0) {
        return null;
    }
    for (const split of splits) {
        logger.debug(`evaluating split sharding`, {
            flagKey,
            subjectKey,
            variationKey: split.variationKey,
            shards: split.shards,
        });
        const matches = split.shards.every((shard) => {
            const shardMatches = (0, matchesShard_1.matchesShard)(shard, subjectKey);
            logger.debug(`shard match result`, {
                flagKey,
                subjectKey,
                variationKey: split.variationKey,
                shard: shard,
                matches: shardMatches,
            });
            return shardMatches;
        });
        if (matches) {
            logger.debug(`subject matches split`, {
                flagKey,
                subjectKey,
                variationKey: split.variationKey,
            });
            return split;
        }
    }
    logger.debug(`subject matches no splits`, {
        flagKey,
        subjectKey,
    });
    return null;
}
//# sourceMappingURL=evaluateForSubject.js.map